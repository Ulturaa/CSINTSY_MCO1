package csintsy.graphrel;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;


import csintsy.file_man.ReadFile;


/**
 * Graph
 */
public class Graph {
  public static final String FILENAME = "test.csv";
  ReadFile rf;
  // Map implmentation from https://www.baeldung.com/java-graphs
  private Map<Integer, ArrayList<Edge>> adjVertices;
<<<<<<< HEAD
  public Map<String, Integer> nameToUid;
=======
  // Map<Integer, ArrayList<Node>> adjNodes;
  Map<String, Integer> nameToUid;
>>>>>>> origin/astarwawo
  Map<Integer, Node> UidToNode;

  /**
   * Initialize Nodes and Edges within Graph constructor.
   */
  public Graph(){
    rf = new ReadFile();
    rf.initRead(FILENAME);
    adjVertices = new HashMap<>();
    nameToUid = new HashMap<>();
    UidToNode = new HashMap<>();
    initGraph();
  };

  /**
   * Initialize Graph with the values read from file the file given
   */
  private void initGraph() {
<<<<<<< HEAD
    for (int i = 0; i < rf.records.size(); i++) {
      List<String> row = rf.records.get(i);
      String nodeName = row.get(0);
      String nodeConn = row.get(1);
=======
    for (List<String> row : rf.records) {
      if (row.size() < 3) continue;

      String fromNodeName = row.get(0);
      String toNodeName = row.get(1);

>>>>>>> origin/astarwawo
      int weight;
      try {
        weight = Integer.parseInt(row.get(2));
      } catch (NumberFormatException e) {
        weight = 0;
      }
<<<<<<< HEAD
      if (nameToUid.get(nodeName) == null) { // if uid or node is still not in adjVertices
        Node newNode = new Node(nodeName);
        addNode(newNode);
      }
      // checks if nodeConn (vertex destination) is not in adjVertices
      // then create that vertex and add it to adjVertices
      if (nameToUid.get(nodeConn) == null) {
        Node newNode = new Node(nodeConn);
        addNode(newNode);
      }
      addEdgeByUid(nameToUid.get(nodeName), nameToUid.get(nodeConn), weight);
      addEdgeByUid(nameToUid.get(nodeConn), nameToUid.get(nodeName), weight);
    }
  } 

  public void printAllNodes() {
=======

      int heuristic = 0;
      if (row.size() >= 4) {
        try {
          heuristic = Integer.parseInt(row.get(3));
        } catch (NumberFormatException e) {
          heuristic = 0;
        }
      }

      // Create or update FROM node
      if (!nameToUid.containsKey(fromNodeName)) {
        Node newFromNode = new Node(fromNodeName, heuristic);
        addNode(newFromNode);
      } else {
        int fromUid = nameToUid.get(fromNodeName);
        UidToNode.get(fromUid).setVal(heuristic); // update heuristic if already exists
      }

      // Create TO node if doesn't exist (no heuristic needed for destination)
      if (!nameToUid.containsKey(toNodeName)) {
        Node newToNode = new Node(toNodeName, 0);
        addNode(newToNode);
      }

      // Add undirected edge
      int fromUid = nameToUid.get(fromNodeName);
      int toUid = nameToUid.get(toNodeName);
      addEdgeByUid(fromUid, toUid, weight);
      addEdgeByUid(toUid, fromUid, weight);
    }
  }

  public void printAllNodes() {
    // for (Node node : nodes) {
    //   System.out.println(node.getName() + ": " + node.getUid() + " = " + node.getVal() + "\n");
    // }
    // for (List<String> row : rf.records) {
    //   for (String string : row) {
    //     System.out.print(string + " ");
    //   }
    //   System.out.println("\n");
    // }
>>>>>>> origin/astarwawo
    Iterator<Map.Entry<Integer, ArrayList<Edge>>> it = adjVertices.entrySet().iterator();
    while (it.hasNext()) {
      Integer key = it.next().getKey();
        System.out.print(UidToNode.get(key).getName());
    }
  }

<<<<<<< HEAD
  public void printNodeEdges() {
    Iterator<Map.Entry<Integer, ArrayList<Edge>>> it = adjVertices.entrySet().iterator();
    while (it.hasNext()) {
      Map.Entry<Integer, ArrayList<Edge>> entry = it.next();
      Integer key = entry.getKey();
      ArrayList<Edge> edges = entry.getValue();
      System.out.print(UidToNode.get(key).getName() + "-> "); 
      for (Edge edge : edges) {
        System.out.print(UidToNode.get(edge.destUid).getName() + "[" + edge.weight + "] ");
      }
      System.out.println();
    }
  }
=======
public void printNodeEdges() {
  Iterator<Map.Entry<Integer, ArrayList<Edge>>> it = adjVertices.entrySet().iterator();
  while (it.hasNext()) {
    Map.Entry<Integer, ArrayList<Edge>> entry = it.next();
    Integer key = entry.getKey();
    ArrayList<Edge> edges = entry.getValue();
    Node currentNode = UidToNode.get(key);

    System.out.print(currentNode.getName() + " (h=" + currentNode.getVal() + ") -> ");

    for (Edge edge : edges) {
      Node destNode = UidToNode.get(edge.dest);
      System.out.print(destNode.getName() + "[" + edge.weight + "] ");
    }
    System.out.println();
  }
}
>>>>>>> origin/astarwawo


  public void addNode(Node n) {
    nameToUid.putIfAbsent(n.getName(), n.getUid());
    UidToNode.putIfAbsent(n.getUid(), n);
    adjVertices.putIfAbsent(n.getUid(), new ArrayList<Edge>());
  }

  public void removeNode(Node n) {
    removeNodeConnections(n.getUid());
    adjVertices.remove(n.getUid());
    nameToUid.remove(n.getName());
    UidToNode.remove(n.getUid());
  }

  public void removeNodeByUid(int uid) {
    removeNode(UidToNode.get(uid));
  }

  public void removeNodeByName(String name) {
    removeNodeByUid(nameToUid.get(name));
  }

  public void addEdgeByUid(int from, int to, int weight) {
    Edge newEdge = new Edge(to, weight);
    adjVertices.get(from).add(newEdge);
  }

<<<<<<< HEAD
  public void removeNodeConnections(int uid) {
    ArrayList<Edge> connections = adjVertices.get(uid);
    for (Edge edge : connections) {
      adjVertices.get(edge.destUid).removeIf(e -> e.destUid == uid);
    }
  }

=======
  private int getHeuristic(String nodeName) { // might use this for computing the total cost
      return 0;
  }

  public void removeNodeConnections(int uid) {
    ArrayList<Edge> connections = adjVertices.get(uid);
    for (Edge edge : connections) {
      adjVertices.get(edge.dest).removeIf(e -> e.dest == uid);
    }
  }

  // public Map<Integer, ArrayList<Edge>> getadjVertices() {
  //   return adjVertices;
  // }

>>>>>>> origin/astarwawo
  public ArrayList<Edge> getNodeEdges(int nodeUid) {
    return adjVertices.get(nodeUid);
  }

  public int getNumberOfNodes() {
    return this.UidToNode.size();
  }

  public Map<Integer, Node> getUidToNode() {
    return UidToNode;
  }

<<<<<<< HEAD
  public String getUidToName(int uid) {
    return UidToNode.get(uid).getName();
=======
  //  A-STAR UPDATES

  public Integer getUidByName(String name) {
      return nameToUid.get(name);
  }

  public Node getNodeByUid(int uid) {
      return UidToNode.get(uid);
  }

  public Map<String, Integer> getNameToUid() {
      return nameToUid;
>>>>>>> origin/astarwawo
  }

}
